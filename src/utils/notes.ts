import { RestEndpointMethodTypes } from '@octokit/rest';

import { Config } from '@/utils/config';

type NotesMeta = Record<string, string>;

function compareNotes(
  commits: RestEndpointMethodTypes['repos']['compareCommitsWithBasehead']['response']['data'],
) {
  let body = `## What's Changed\n`;
  commits.commits.forEach((commit) => {
    body += `* [${commit.sha.substring(0, 7)}](${commit.html_url}) - ${commit.commit.message}`;
    if (commit.author && commit.committer) {
      body += ` (by `;
      body += `[${commit.author.login}](${commit.author.html_url})`;
      if (commit.committer.name !== commit.author.name) {
        body += ` & [${commit.committer.login}](${commit.committer.html_url})`;
      }
      body += `)`;
    } else if (commit.author) {
      body += ` (authored by `;
      body += `[${commit.author.login}](${commit.author.html_url})`;
      body += `)`;
    } else if (commit.committer) {
      body += ` (committed by `;
      body += `[${commit.committer.login}](${commit.committer.html_url})`;
      body += `)`;
    }
    body += '\n';
  });
  body += `\n[Compare changes](${commits.html_url})\n`;
  return body;
}

export const createNotes = (
  commits: RestEndpointMethodTypes['repos']['compareCommitsWithBasehead']['response']['data'],
  meta: NotesMeta,
  { action }: Pick<Config, 'action'>,
) => {
  let body = `\n<!-- ${action.name} - summary begin -->`;
  body += `\n## Summary\n\nFill in here the summary of the release.`;
  body += `\n<!-- ${action.name} - summary end -->`;
  body += `\n\n---\nAutomatically generated by [${action.name}](${action.url})`;
  body += `\n<!-- ${action.name} - meta begin -->`;
  for (const [key, value] of Object.entries(meta)) {
    body += `\n<!-- ${key} = ${value} -->`;
  }
  body += `\n<!-- ${action.name} - meta end -->`;
  return `${compareNotes(commits)}${body}`;
};

export const updateNotes = (
  commits: RestEndpointMethodTypes['repos']['compareCommitsWithBasehead']['response']['data'],
  body: string | null,
  { action }: Pick<Config, 'action'>,
) => {
  if (!body) {
    throw new Error('No body provided to updateNotes');
  }

  // Extract the existing summary and meta using the action's tags
  const summaryBeginTag = `<!-- ${action.name} - summary begin -->`;
  const summaryEndTag = `<!-- ${action.name} - summary end -->`;
  const metaBeginTag = `<!-- ${action.name} - meta begin -->`;
  const metaEndTag = `<!-- ${action.name} - meta end -->`;

  const summaryBeginIndex = body.indexOf(summaryBeginTag);
  const summaryEndIndex = body.indexOf(summaryEndTag);
  const metaBeginIndex = body.indexOf(metaBeginTag);
  const metaEndIndex = body.indexOf(metaEndTag);

  let summaryText = '';
  let metaText = '';

  if (summaryBeginIndex !== -1 && summaryEndIndex !== -1) {
    summaryText = body.substring(summaryBeginIndex, summaryEndIndex + summaryEndTag.length);
  }

  if (metaBeginIndex !== -1 && metaEndIndex !== -1) {
    metaText = body.substring(metaBeginIndex, metaEndIndex + metaEndTag.length);
  }

  // Construct new body with updated notes, existing summary, and meta information
  return `${compareNotes(commits)}\n\n${summaryText}\n\n---\nAutomatically generated by [${action.name}](${action.url})\n\n${metaText}`;
};

export const notesMeta = (body: string, { action }: Pick<Config, 'action'>): NotesMeta => {
  const metaBeginTag = `<!-- ${action.name} - meta begin -->`;
  const metaEndTag = `<!-- ${action.name} - meta end -->`;
  const metaStartIndex = body.indexOf(metaBeginTag);
  const metaEndIndex = body.indexOf(metaEndTag);

  const metaRecord: NotesMeta = {};

  if (metaStartIndex !== -1 && metaEndIndex !== -1) {
    // Extract the meta content
    const metaContent = body.substring(metaStartIndex + metaBeginTag.length, metaEndIndex).trim();

    // Split the content into lines and then into key-value pairs
    const metaLines = metaContent
      .split('\n')
      .filter((line) => line.startsWith('<!--') && line.endsWith('-->'));

    for (const line of metaLines) {
      // Removing comment tags and extra spaces
      const cleanedLine = line.replace('<!--', '').replace('-->', '').trim();

      // Splitting the line into key and value by '='
      const [key, value] = cleanedLine.split('=').map((part) => part.trim());

      if (key && value) {
        metaRecord[key] = value;
      }
    }
  }

  return metaRecord;
};
